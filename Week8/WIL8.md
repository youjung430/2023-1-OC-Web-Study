# GDSC 웹스터디 8주차
정적인 웹사이트 + javascript -> 프로그램처럼 사용 가능. web 어플리케이션.   
## Javascript
: 상호작용 가능, 데이터 송수신 가능, DOM 조정 가능   
<br>
### 변수
값을 저장(할당)하고 그 저장된 값을 참조하기 위해 사용. 재활용 가능.   
Javascript에서는 **자료형이 없음.** 변수에 할당된 값의 타입에 의해 동적으로 변수의 타입이 결정됨. -> **동적 타이핑**
```javascript
var example1 = 10;
let example2 = 10;
const example3 = 10; // 상수. example3 = 30; 불가능
```
선언 vs 할당

```javascript
var example1 // 선언
var example1 = 10 / 할당
```
var : 재선언, 재할당 가능.     
let : 재할당만 가능. 재선언은 오류.    
```javascript
var a = 3;
var a = 4;

let b = 3;
let b = 4; // 오류

var aa = 3;
aa = 4;

let bb = 3;
bb = 4; // 가능
```
### 스코프   
- 함수 레벨 스코프 : 함수 내에서 선언된 변수는 함수 내에서만 유효. 함수 외부에서는 참조할 수 없음. -> var
- 블록 레벨 스코프 : 모든 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하고 블록 외부에서는 참조할 수 없음. -> let, const
```javascript
if (true){
	var block_a = 3;
}
console.log(block_a);

if(true){
	let block_b = 3;
}
console.log(block_b); // block_b가 존재하지 않음. let, const는 블록 안에서만 존재함.
```

### 호이스팅   
: var 키워드로 선언된 변수는 선언 단계와 초기화 단계(undefined로)가 한번에 이루어진다. 변수를 선언하기 이전에 참조할 수 있다.   
let 키워드로 선언된 변수는 스코프에 변수를 등록하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다. 초기화 이전에 접근하려고 하면 참조 에러가 발생한다.
```javascript
console.log(foo); // undefined를 리턴. var foo; 가 맨 위에 선언된것처럼 작동함. 지양하는게 좋음
var foo = 123;
console.log(foo);
{
	var foo = 456;
}
console.log(foo);
```
### 스코프
참조 대상 식별자를 찾아내기 위한 규칙. ex) 이름이 같은 변수 x가 중복 선언 되었을때 어떤 변수를 참조해야 하는가?   
- 전역 스코프 : 코드 어디에서든지 참조할 수 있다. 전역변수.
- 지역 스코프 : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다. 지역변수.
<br>

### 연산자
- 이항 산술 연산자 : + - * / %
- 단항 산술 연산자 : ++ -- +(피연산자 숫자로 반환) -(피연산자 부호 반전, 피연산자 숫자로 반환)
- 할당 연산자 : = += -= *= /= %=
- 비교 연산자
    - == : 동등 비교. x와 y의 값이 같음. 
    - === : 일치 비교. x와 y의 값과 타입이 같음.
    - != : 부등 비교. x와 y의 값이 다름.
    - !== : 불일치 비교. x와 y의 값과 타입이 다름.

### 타입 변환
암묵적 형 변환   
: 자바스크립트는 엔진에 의해 암묵적으로 오른쪽에 있는 것을 왼쪽에 있는 타입으로 자동변환된다.
```javascript
0 == 0 // true
0 == '0' // true
0 == [] // true
[] == "0" // false

0 === '0' //false
```
```javascript
'10' + 2 // '102'
5 * '10' // 50
!0 // true
'1' > 0 // true
```
암묵적 타입 변환의 경우 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러나지 않으므로 자신의 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지 예측 가능해야 한다.
